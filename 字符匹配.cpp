/*
二进制字符串匹配
时间限制：3000 ms | 内存限制：65535 KB
难度：3
描述
给定两个字符串A和B，其字母表只包含'0'和'1'。你的任务只是告诉A有多少次显示为B的子串？例如，文本字符串B是'1001110110'，而模式字符串A是'11'，则应该输出3，因为模式A出现在位置
输入
第一行只包含一个整数N，表示N个情况如下。在每种情况下，有两行，第一行给出字符串A，长度（A）<= 10，第二行给出字符串B，长度（B）<= 1000。并且保证B总是长于A.
输出
对于每种情况，输出一行代表一个整数，告诉B出现的次数是多少次。
样例输入
3
11
1001110110
101
110010010010001
1010
110100010101011
样例输出
3
0
3
优化不好，需要进一步改进
*/
#include<iostream>

using namespace std;

int main()
{
	int N = 0;
	cin >> N;
	while (N > 0)
	{
		char A[10];
		char B[1000];
		cin >> A;
		cin >> B;
		int  i = 0, sum = 0;
		while (B[i] != '\0')
		{
			int j = 0, flag = 1, k = i;
			while (A[j] != '\0')
			{
				if (A[j] != B[k])
				{
					flag = 0;
					break;
				}
				j++;
				k++;
			}
			if (flag == 1)
			{
				sum++;
			}
			i++;
		}
		cout << sum << endl;
		N--;
	}
	return 0;
}